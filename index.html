<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title> Filter Envelope</title>

    <link rel="stylesheet" type="text/css" href="style.css">

    <script src="libraries/p5.min.js"></script>
    <script src="libraries/p5.sound.min.js"></script>
    <script src="libraries/p5.func.min.js"></script>

    <style>
      :root{
        --bg:#0e0f12;
        --panel:#16181d;
        --ink:#e6edf3;
        --muted:#9aa4b2;
        --accent:#4cc2ff;
        --grid:#1e222a;
        --good:#7ee787;
      }
      html,body{
        height:100%;
        margin:0;
        background:var(--bg);
        color:var(--ink);
        font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Inter,Roboto,Ubuntu,Cantarell,'Helvetica Neue',Arial,'Noto Sans',sans-serif;
      }
      main{
        max-width:1100px;
        margin:0 auto;
        padding:16px;
      }
      canvas{
        display:block;
        margin:0 auto 16px auto;
        border-radius:8px;
        box-shadow:0 0 0 1px #000 inset, 0 8px 32px rgba(0,0,0,0.4);
      }
      .ui{
        background:var(--panel);
        border-radius:12px;
        padding:12px 16px;
        box-shadow:0 0 0 1px #0b0c10 inset;
      }
      .row{
        display:flex;
        align-items:center;
        gap:12px;
        flex-wrap:wrap;
        margin:8px 0;
      }
      .row label{
        width:92px;
        color:var(--muted);
        font-size:12px;
        text-transform:uppercase;
        letter-spacing:.08em;
      }
      .value{
        min-width:64px;
        text-align:right;
        color:var(--ink);
        font-variant-numeric:tabular-nums;
        font-size:12px;
      }
      .row input[type="range"]{
        -webkit-appearance:none;
        width:100%;
        height:4px;
        border-radius:999px;
        background:linear-gradient(90deg,var(--accent),#7aa2ff);
        outline:none;
        flex:1 1 220px;
        min-width:160px;
        max-width:420px;
      }
      input[type="range"]::-webkit-slider-thumb{
        -webkit-appearance:none;
        width:16px;height:16px;border-radius:50%;
        background:var(--ink); border:2px solid var(--panel);
        box-shadow:0 1px 2px rgba(0,0,0,.5);
        cursor:pointer;
      }
      button.gate{
        background:linear-gradient(180deg,#2a313f,#1c212b);
        color:var(--ink);
        border:1px solid #0b0c10;
        border-radius:8px;
        padding:10px 14px;
        font-weight:600;
        cursor:pointer;
      }
      button.gate:active{ transform:translateY(1px); }
      .hint{
        color:var(--muted);
        font-size:12px;
        margin-top:6px;
      }
      @media (max-width: 640px){
        .row{ gap:8px; }
        .row label{ width:72px; }
      }
    </style>
  </head>

  <body>
    <main>
      <div id="ui" class="ui"></div>
      <div class="hint">Hold the button or press Z/Space. Envelope drives low‑pass cutoff; sliders update audio and visuals.</div>
      <script >/* Polymetric Trips - Filter Envelope UI + Audio (p5 + p5.sound) */

let osc, filter, ampEnv;
let isAudioReady = false;

// Gate state for manual envelope evaluation (for cutoff modulation)
let gateOn = false;
let gateStartSec = 0;
let releaseStartSec = 0;
let releaseStartLevel = 0;

// Controls
let uiRoot;
let attackS, decayS, sustainS, releaseS;
let minCutoffS, maxCutoffS, resonanceS;
let gateBtn;

// Cached values
let A = 0.02, D = 0.15, S = 0.6, R = 0.3;
let minCutHz = 200, maxCutHz = 4000, qRes = 6;

function setup() {
  const w = Math.min(windowWidth - 32, 1080);
  const h = Math.round(Math.min(windowHeight - 220, 520));
  createCanvas(w, Math.max(280, h));

  buildUI();
  noStroke();
}

function windowResized() {
  const w = Math.min(windowWidth - 32, 1080);
  const h = Math.round(Math.min(windowHeight - 220, 520));
  resizeCanvas(w, Math.max(280, h));
}

function buildUI() {
  uiRoot = select('#ui');

  const rows = [];

  rows.push(makeSliderRow('Attack', 0, 2000, 1, 50, v => `${(v/1000).toFixed(2)}s`, s => attackS = s));
  rows.push(makeSliderRow('Decay', 0, 3000, 1, 150, v => `${(v/1000).toFixed(2)}s`, s => decayS = s));
  rows.push(makeSliderRow('Sustain', 0, 1000, 1, 600, v => `${(v/1000).toFixed(2)}`, s => sustainS = s));
  rows.push(makeSliderRow('Release', 0, 4000, 1, 300, v => `${(v/1000).toFixed(2)}s`, s => releaseS = s));

  rows.push(makeSliderRow('Cutoff Min', 0, 1000, 1, hzToNorm(200)*1000, v => {
    const hz = normToHz(v/1000);
    return `${fmtHz(hz)}`;
  }, s => minCutoffS = s));

  rows.push(makeSliderRow('Cutoff Max', 0, 1000, 1, hzToNorm(4000)*1000, v => {
    const hz = normToHz(v/1000);
    return `${fmtHz(hz)}`;
  }, s => maxCutoffS = s));

  rows.push(makeSliderRow('Resonance', 5, 200, 1, 60, v => {
    return `Q ${(v/10).toFixed(1)}`;
  }, s => resonanceS = s));

  // Gate button
  const row = createDiv().addClass('row').parent(uiRoot);
  const lab = createElement('label', 'Gate').parent(row);
  const btn = createButton('Hold to Play').addClass('gate').parent(row);
  btn.mousePressed(handlePress);
  btn.mouseReleased(handleRelease);
  gateBtn = btn;

  // Keyboard
  window.addEventListener('keydown', e => {
    if (e.repeat) return;
    if (e.code === 'Space' || e.key === 'z' || e.key === 'Z') {
      e.preventDefault();
      handlePress();
    }
  });
  window.addEventListener('keyup', e => {
    if (e.code === 'Space' || e.key === 'z' || e.key === 'Z') {
      e.preventDefault();
      handleRelease();
    }
  });
}

function makeSliderRow(labelText, min, max, step, val, fmt, assign) {
  const row = createDiv().addClass('row').parent(uiRoot);
  createElement('label', labelText).parent(row);
  const slider = createSlider(min, max, val, step).parent(row);
  const valEl = createSpan('').addClass('value').parent(row);
  const update = () => {
    valEl.html(fmt(slider.value()));
  };
  slider.input(update);
  update();
  assign(slider);
  return row;
}

function ensureAudio() {
  if (isAudioReady) return;
  const ctx = getAudioContext();
  if (ctx.state !== 'running') ctx.resume();

  osc = new p5.Oscillator('sawtooth');
  filter = new p5.Filter('lowpass');
  ampEnv = new p5.Envelope();

  // Signal flow: osc -> filter -> master
  osc.disconnect();
  osc.connect(filter);
  filter.connect(); // to master

  // Base tone
  osc.freq(110); // A2
  osc.start();

  // Very low base amp; envelope will shape audible level
  osc.amp(0);

  isAudioReady = true;
}

function handlePress() {
  ensureAudio();
  if (!isAudioReady) return;

  // Update parameters from UI
  syncParamsFromUI();

  // Set amp envelope and trigger
  ampEnv.setADSR(A, D, S, R);
  ampEnv.setRange(0.35, 0.0001);
  ampEnv.triggerAttack(osc);

  // Gate state for cutoff envelope
  gateOn = true;
  gateStartSec = millis()/1000;
}

function handleRelease() {
  if (!isAudioReady) return;
  ampEnv.triggerRelease(osc);

  // Compute current level at release to start release segment of cutoff env
  const now = millis()/1000;
  releaseStartLevel = evalEnvLevel(now - gateStartSec); // level at release
  releaseStartSec = now;
  gateOn = false;
}

function draw() {
  background('#0e0f12');
  drawGrid();

  // Sync params every frame for responsiveness
  syncParamsFromUI();

  // Evaluate current envelope level and apply to filter cutoff
  const now = millis()/1000;
  let level;
  if (gateOn) {
    level = evalEnvLevel(now - gateStartSec);
  } else {
    level = evalReleaseLevel(now - releaseStartSec, releaseStartLevel);
  }
  const cutoff = lerp(minCutHz, maxCutHz, constrain(level, 0, 1));
  if (isAudioReady) {
    filter.freq(cutoff);
    filter.res(qRes); // p5.Filter Q
  }

  drawEnvelopeVis(level);
  drawCutoffBar(cutoff);
}

// Sync UI -> params with constraints
function syncParamsFromUI() {
  if (!attackS) return;
  A = attackS.value()/1000;
  D = decayS.value()/1000;
  S = sustainS.value()/1000;
  R = releaseS.value()/1000;

  // Ensure min <= max
  const minN = minCutoffS.value()/1000;
  const maxN = maxCutoffS.value()/1000;
  if (minN > maxN) {
    maxCutoffS.value(minCutoffS.value());
  }
  minCutHz = normToHz(minCutoffS.value()/1000);
  maxCutHz = normToHz(maxCutoffS.value()/1000);

  qRes = resonanceS.value()/10;
}

// Manual ADSR evaluation for visualization and cutoff driving
function evalEnvLevel(t) {
  if (t <= 0) return 0;
  if (t < A) {
    return t / Math.max(A, 1e-6);
  }
  const t2 = t - A;
  if (t2 < D) {
    const dNorm = t2 / Math.max(D, 1e-6);
    return 1 - (1 - S) * dNorm;
  }
  return S;
}

function evalReleaseLevel(tSinceRelease, startLevel) {
  if (tSinceRelease <= 0) return startLevel || 0;
  if (R <= 0) return 0;
  const r = 1 - (tSinceRelease / R);
  if (r <= 0) return 0;
  return (startLevel || 0) * r;
}

function drawGrid() {
  push();
  const pad = 16;
  const w = width - pad*2;
  const h = height - pad*2;
  translate(pad, pad);

  // Panel bg
  noStroke();
  fill('#16181d');
  rect(0, 0, w, h, 12);

  // Subtle grid
  stroke('#1e222a');
  strokeWeight(1);
  const rows = 6, cols = 16;
  for (let i=1;i<rows;i++) {
    const y = (i/rows)*h;
    line(0, y, w, y);
  }
  for (let j=1;j<cols;j++) {
    const x = (j/cols)*w;
    line(x, 0, x, h);
  }

  pop();
}

function drawEnvelopeVis(currentLevel) {
  push();
  const pad = 24;
  const w = width - pad*2;
  const h = height*0.6;
  translate(pad, 24);

  // Construct normalized ADSR path (sustain shown as dashed; fixed preview sustain duration)
  const previewSustain = 0.8; // seconds, for visualization only
  const total = Math.max(0.2, A + D + R + previewSustain);
  const sx = w / total;

  noFill();
  stroke('#4cc2ff');
  strokeWeight(2);

  // Attack
  beginShape();
  vertex(0, h); // start at 0 level
  vertex(A*sx, h - h); // top
  // Decay to sustain
  vertex((A + D)*sx, h - h*S);
  // Sustain segment (dashed imitation)
  const sustStartX = (A + D)*sx;
  const sustEndX = (A + D + previewSustain)*sx;
  endShape();

  // Sustain dashed
  setLineDash([6,6]);
  line(sustStartX, h - h*S, sustEndX, h - h*S);
  setLineDash([]);
  // Release
  beginShape();
  vertex(sustEndX, h - h*S);
  vertex(sustEndX + R*sx, h); // back to 0
  endShape();

  // Current level marker
  const xNow = map(currentLevel, 0, 1, 0, w); // not time-accurate; level indicator only
  stroke('#7ee787');
  strokeWeight(6);
  point(xNow, h - h*currentLevel);

  // Labels
  noStroke();
  fill('#9aa4b2');
  textSize(12);
  text('Envelope (ADSR)', 2, -6);

  pop();
}

function drawCutoffBar(cutoffHz) {
  push();
  const pad = 24;
  const w = width - pad*2;
  const y = height - 60;
  translate(pad, 0);

  // Scale on log axis
  const xMin = 0;
  const xMax = w;
  const xFromHz = hz => {
    const n = hzToNorm(hz);
    return lerp(xMin, xMax, n);
  };

  // Rail
  stroke('#1e222a');
  strokeWeight(6);
  line(0, y, w, y);

  // Range
  stroke('#4cc2ff');
  strokeWeight(6);
  line(xFromHz(minCutHz), y, xFromHz(maxCutHz), y);

  // Current cutoff
  stroke('#7ee787');
  strokeWeight(10);
  point(xFromHz(cutoffHz), y);

  // Ticks and labels
  noStroke();
  fill('#9aa4b2');
  textSize(12);
  const ticks = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
  for (const t of ticks) {
    const x = xFromHz(t);
    stroke('#1e222a');
    strokeWeight(1);
    line(x, y-10, x, y+10);
    noStroke();
    fill('#9aa4b2');
    textAlign(CENTER);
    text(fmtHz(t), x, y+24);
  }

  // Legend
  textAlign(LEFT);
  text(`Cutoff: ${fmtHz(cutoffHz)}  |  Range: ${fmtHz(minCutHz)} – ${fmtHz(maxCutHz)}  |  Q ${qRes.toFixed(1)}`, 0, y-16);

  pop();
}

function setLineDash(list) {
  drawingContext.setLineDash(list);
}

// Utils

function normToHz(n) {
  const min = 20, max = 20000;
  const ratio = max / min; // 1000
  return min * Math.pow(ratio, n);
}

function hzToNorm(hz) {
  const min = 20, max = 20000;
  const ratio = max / min;
  return constrain(Math.log(hz/min)/Math.log(ratio), 0, 1);
}

function fmtHz(hz) {
  if (hz >= 1000) return `${(hz/1000).toFixed(hz<10000?2:1)} kHz`;
  return `${Math.round(hz)} Hz`;
}</script>
    </main>
  </body>
</html>
